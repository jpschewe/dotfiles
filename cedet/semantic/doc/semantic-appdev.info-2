This is semantic-appdev.info, produced by makeinfo version 4.3 from
app-dev-guide.texi.

This manual documents Application Development with Semantic.

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam
Copyright (C) 2001, 2002, 2003, 2004 David Ponce Copyright (C) 2002,
2003 Richard Y. Kim

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with the Invariant Sections being list their titles,
     with the Front-Cover Texts being list, and with the Back-Cover
     Texts being list.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Semantic Application Writer's guide: (semantic-appdev).
END-INFO-DIR-ENTRY

   This file documents Application Development with Semantic.
_Infrastructure for parser based text analysis in Emacs_

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam,
David Ponce, and Richard Y. Kim


File: semantic-appdev.info,  Node: Tag Completion,  Next: Override Methods,  Prev: Tag Sorting,  Up: Top

Tag Completion
**************

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time, the
semantics can be quite complex.  If two tags have the same name, which
do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the "interactive" command like this:

     (defun my-function (tag)
        "Do something to TAG."
        (interactive (list (my-completion-function "Tag: ")))
        ...)

* Menu:

* Tag Completion Convenience Functions::  Provided functions
* Custom Tag Completion Functions::  Build your own completion function
* Old Tag Completion::          Completion functions from older releases


File: semantic-appdev.info,  Node: Tag Completion Convenience Functions,  Next: Custom Tag Completion Functions,  Up: Tag Completion

Tag Completion Convenience Functions
====================================

There are some pre written completion functions that can be used in your
programs.

 - Function: semantic-complete-read-tag-buffer-deep prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current buffer.  Available tags are
     from the current buffer, at any level.  Completion options are
     presented in a traditional way, with highlighting to resolve
     same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to story
     the history in.


File: semantic-appdev.info,  Node: Custom Tag Completion Functions,  Next: Old Tag Completion,  Prev: Tag Completion Convenience Functions,  Up: Tag Completion

Custom Tag Completion Functions
===============================

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

Tag Collection
     Something that selects tags, and provides some list of tags
     available, such as all functions, or all classes named "bob".

Typing and selecting
     The prompt where you can type in the name of a tag.

Displaying possible completion values
     A mechanism for displaying completion lists.

There is one typing and selecting routine that can be used to create
your custom completion prompt.

 - Function: semantic-complete-read-tag-engine collector displayor
          prompt default-tag initial-input history
     Read a semantic tag, and return a tag for the selection.  Argument
     COLLECTOR is a function which can be used to to return a list of
     possible hits.  See `semantic-completion-collector-engine' for
     details on COLLECTOR.  Argumeng DISPLAYOR is a function used to
     display a list of possible completions for a given prefix.
     See`semantic-completion-display-engine' for details on DISPLAYOR.
     PROMPT is a string to prompt with.  DEFAULT-TAG is a semantic tag
     or string to use as the default value.  If INITIAL-INPUT is
     non-`nil', insert it in the minibuffer initially.  HISTORY is a
     symbol representing a variable to story the history in.

As you can see, this takes one "collector", and one "displayor".  These
are objects created for this prompt at runtime.  The completion engine
then uses to perform their tasks.

For example:

     (defun semantic-complete-read-tag-buffer-deep (prompt &optional
     						      default-tag initial-input history)
       "Ask for a tag by name from the current buffer.
     PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default value.
     If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
     HISTORY is a symbol representing a variable to story the history in."
       (semantic-complete-read-tag-engine
        (semantic-collector-buffer-deep prompt :buffer (current-buffer))
        (semantic-displayor-traditional-with-focus-highlight "simple")
        ;;(semantic-displayor-tooltip "simple")
        prompt
        default-tag
        initial-input
        history)
       )

* Menu:

* Tag Collectors::
* Tag Displayors::


File: semantic-appdev.info,  Node: Tag Collectors,  Next: Tag Displayors,  Up: Custom Tag Completion Functions

Tag Collectors
--------------

A tag collector is an object that inherits from
"semantic-collector-abstract".  A new collector is needed for each
specialized type of prompt that draws from a different selection of
tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

All collectors inherit from:

 - Type: semantic-collector-abstract
     Root class for completion engines.

Available instantiable classes are:

 - Type: semantic-collector-buffer-deep
     Completion engine for tags in the current buffer.  Provides deep
     searches through types.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Tag Displayors,  Prev: Tag Collectors,  Up: Custom Tag Completion Functions

Tag Displayors
--------------

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to focus one one particular tag
of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

 - Type: semantic-displayor-abstract
     Manages the display of some number of tags.

Distinct implementations of displayors include:

 - Type: semantic-displayor-traditional
     Traditional display mechanism for a list of possible completions.

 - Type: semantic-displayor-traditional-with-focus-highlight
     A traditional displayor which can focus on a tag by showing it.

 - Type: semantic-displayor-tooltip
     Display mechanism using tooltip for a list of possible completions.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Old Tag Completion,  Prev: Custom Tag Completion Functions,  Up: Tag Completion

Older Tag Completion functions
==============================

These are older completion functions.  They may still be useful.

 - Function: semantic-read-symbol prompt &optional default stream filter
     Read a symbol name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.  FILTER is provides a
     filter on the types of things to complete.  FILTER must be a
     function to call on each element.  (See !!!

 - Function: semantic-read-variable prompt &optional default stream
     Read a variable name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 - Function: semantic-read-function prompt &optional default stream
     Read a function name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 - Function: semantic-read-type prompt &optional default stream
     Read a type name from the user for the current buffer.  PROMPT is
     the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.


File: semantic-appdev.info,  Node: Override Methods,  Next: Parser Features,  Prev: Tag Completion,  Up: Top

Override Methods
****************

These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

If you plan to use one of these functions from a buffer that is not of
the same major-mode as the original tag, you can use this form to make
sure th correct action takes place:

 - Function: semantic-with-mode-bindings mode &rest body
     Evaluate BODY with the local bindings of MODE.  The current mode
     bindings are saved, BODY is evaluated, and the saved bindings are
     restored, even in case of an abnormal exit.  Value is what BODY
     returns.

For more on override methods, *note (lang-support-guide)Semantic
Overload Mechanism::.

* Menu:

* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Making New Methods::          How to add your own methods for a tool


File: semantic-appdev.info,  Node: Format Tag,  Next: Tag Members,  Up: Override Methods

Format Tag
==========

Any given tag consists of Meta information which is best viewed in some
textual form.  This could be as simple as the tag's name, or as a
prototype to be added to header file in C.  Not only are there several
default converters from a Tag into text, but there is also some
convenient variables that can be used with them.  Use these variables
to allow options on output forms when displaying tags in your programs.

 - Variable: semantic-format-tag-functions
     List of functions which convert a tag to text.  Each function must
     take the parameters TAG &optional PARENT COLOR.  TAG is the tag to
     convert.  PARENT is a parent tag or name which refers to the
     structure or class which contains TAG.  PARENT is NOT a class
     which a TAG would claim as a parent.  COLOR indicates that the
     generated text should be colored using `font-lock'.

 - Variable: semantic-format-tag-custom-list
     A List used by customizeable variables to choose a tag to text
     function.  Use this variable in the `:type' field of a
     customizable variable.

Every tag to text conversion function must take the same parameters,
which are TAG, the tag to be converted, PARENT, the containing parent
(like a structure which contains a variable), and COLOR, which is a
flag specifying that color should be applied to the returned string.

When creating, or using these strings, particularly with color, use
"concat" to build up larger strings instead of "format".  This will
preserve text properties.

 - Function: semantic-format-tag-name tag &optional parent color
     Return the name string describing TAG.  The name is the shortest
     possible representation.  Optional argument PARENT is the parent
     type if TAG is a detail.  Optional argument COLOR means highlight
     the prototype with font-lock colors.

 - Function: semantic-format-tag-abbreviate tag &optional parent color
     Return an abbreviated string describing TAG.  The abbreviation is
     to be short, with possible symbols indicating the type of tag, or
     other information.  Optional argument PARENT is the parent type if
     TAG is a detail.  Optional argument COLOR means highlight the
     prototype with font-lock colors.

 - Function: semantic-format-tag-summarize tag &optional parent color
     Summarize TAG in a reasonable way.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-prototype tag &optional parent color
     Return a prototype for TAG.  This function should be overloaded,
     though it need not be used.  This is because it can be used to
     create code by language independent tools.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-concise-prototype tag &optional parent
          color
     Return a concise prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-abbreviate tag &optional parent
          color
     Return a UML style abbreviation for TAG.  Optional argument PARENT
     is the parent type if TAG is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-prototype tag &optional parent
          color
     Return a UML style prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-uml-concise-prototype tag &optional
          parent color
     Return a UML style concise prototype for TAG.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.

 - Function: semantic-format-tag-prin1 tag &optional parent color
     Convert TAG to a string that is the print name for TAG.  PARENT
     and COLOR are ignored.

An additional utility will return a string for just the data type of a
tag.  This function is used in the above routines as well.

 - Function: semantic-format-tag-type tag color
     Convert the data type of TAG to a string usable in tag formatting.
     It is presumed that TYPE is a string or semantic tag.  This
     function can be overriden in semantic using the symbol
     `format-tag-type'.


File: semantic-appdev.info,  Node: Tag Members,  Next: Tag Details,  Prev: Format Tag,  Up: Override Methods

Tag Members
===========

Tags are often in a hierarchical form, meaning that a tag found in the
top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

 - Function: semantic-tag-components tag
     Return a list of components for TAG.  A Component is a part of TAG
     which itself may be a TAG.  Examples include the elements of a
     structure in a ``type' tag, or the list of arguments to a
     `'function' tag.

 - Function: semantic-tag-components-with-overlays tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.

     Default behavior is to get "semantic-tag-components" in addition
     to the components of an anonymous types (if applicable.)

     Note for language authors:   If a mode defines a language tag that
     has tags in it with overlays you should still return them with
     this function.  Ignoring this step will prevent several features
     from working correctly.

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.

 - Function: semantic-tag-external-member-p parent token
     Return non-`nil' if PARENT is the parent of TAG.  TAG is an
     external member of PARENT when it is somehow tagged as having
     PARENT as it's parent.  PARENT and TAG must both be semantic tags.

     The default behavior, if not overridden with
     `tag-external-member-p' is to match `'parent' extra specifier in
     the name of TAG.

     If this function is overridden, use
     `semantic-tag-external-member-children-p-default' to also include
     the default behavior, and merely extend your own.

 - Function: semantic-tag-external-member-children tag &optional usedb
     Return the list of children which are not *in* TAG.  If optional
     argument USEDB is non-`nil', then also search files in the
     Semantic Database.  If USEDB is a list of databases, search those
     databases.

     Children in this case are functions or types which are members of
     TAG, such as the parts of a type, but which are not defined inside
     the class.  C++ and CLOS both permit methods of a class to be
     defined outside the bounds of the class' definition.

     The default behavior, if not overridden with
     `tag-external-member-children' is to search using
     "semantic-tag-external-member-p" in all top level definitions with
     a parent of TAG.

     If this function is overridden, use
     "semantic-tag-external-member-children-default" to also include
     the default behavior, and merely extend your own.


File: semantic-appdev.info,  Node: Tag Details,  Next: Making New Methods,  Prev: Tag Members,  Up: Override Methods

Tag Details
===========

These functions help derive information about tags that may not be
obvious for non-traditional languages with their own token types.

 - Function: semantic-tag-protection tag &optional parent
     Return protection information about TAG with optional PARENT.
     This function returns on of the following symbols:    `nil'
     - No special protection.  Language dependent.     `'public'    -
     Anyone can access this TAG.     `'private'   - Only methods in the
     local scope can access TAG.     `'protected' - Like private for
     outside scopes, like public for child                 classes.
     Some languages may choose to provide additional return symbols
     specific to themselves.  Use of this function should allow for
     this.

     The default behavior (if not overridden with `tag-protection' is
     to return a symbol based on type modifiers.

     *Compatibility*: `semantic-tag-protection' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-protection' which is
     now obsolete.

 - Function: semantic-tag-protected-p tag protection &optional parent
     Non-`nil' if TAG is is protected.  PROTECTION is a symbol which
     can be returned by the method "semantic-tag-protection".  PARENT
     is the parent data type which contains TAG.

     For these PROTECTIONs, true is returned if TAG is:
    `nil'
          Always true

    private
          True if `nil'.

    protected
          True if private or `nil'.

    public
          True if private, protected, or `nil'.

 - Function: semantic-tag-abstract-p tag &optional parent
     Return non `nil' if TAG is abstract.  Optional PARENT is the
     parent tag of TAG.  In UML, abstract methods and classes have
     special meaning and behavior in how methods are overridden.  In
     UML, abstract methods are italicized.

     The default behavior (if not overridden with `tag-abstract' is to
     return true if `abstract' is in the type modifiers.

     *Compatibility*: `semantic-tag-abstract-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-abstract' which is now
     obsolete.

 - Function: semantic-tag-leaf-p tag &optional parent
     Return non `nil' if TAG is leaf.  Optional PARENT is the parent
     tag of TAG.  In UML, leaf methods and classes have special meaning
     and behavior.

     The default behavior (if not overridden with `tag-leaf' is to
     return true if `leaf' is in the type modifiers.

     *Compatibility*: `semantic-tag-leaf-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-leaf' which is now obsolete.

 - Function: semantic-tag-static-p tag &optional parent
     Return non `nil' if TAG is static.  Optional PARENT is the parent
     tag of TAG.  In UML, static methods and attributes mean that they
     are allocated in the parent class, and are not instance specific.
     UML notation specifies that STATIC entries are underlined.  This
     function can be overriden in semantic using the symbol
     `tag-static-p'.

     *Compatibility*: `semantic-tag-static-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-static' which is now obsolete.

 - Variable: semantic-dependency-include-path
     Defines the include path used when searching for files.  This
     should be a list of directories to search which is specific to the
     file being included.  If "semantic-find-dependency" is overridden
     for a given language, this path is most likely ignored.

     TODO: use ffap.el to locate such items.

 - Function: semantic-dependency-tag-file &optional tag
     Find the filename represented from TAG.  Depends on
     `semantic-dependency-include-path' for searching.  Always searches
     `.' first, then searches additional paths.

     *Compatibility*: `semantic-dependency-tag-file' introduced in
     semantic version 2.0 supercedes `semantic-find-dependency' which
     is now obsolete.

 - Function: semantic-prototype-file buffer
     Return a file in which prototypes belonging to BUFFER should be
     placed.  Default behavior (if not overridden) looks for a token
     specifying the prototype file, or the existence of an EDE variable
     indicating which file prototypes belong in.

 - Function: semantic-go-to-tag &optional tag parent
     Go to the location of TAG.  TAG may be a stripped element, in
     which case PARENT specifies a parent tag that has position
     information.  Different behaviors are provided depending on the
     type of tag.  For example, dependencies (includes) will seek out
     the file that is depended on (see "semantic-dependency-tag-file".

     *Compatibility*: `semantic-go-to-tag' introduced in semantic
     version 2.0 supercedes `semantic-find-nonterminal' which is now
     obsolete.

 - Function: semantic-texi-find-documentation name &optional type
     Find the function or variable NAME of TYPE in the texinfo source.
     NAME is a string representing some functional symbol.  TYPE is a
     string, such as "variable" or "Command" used to find the correct
     definition in case NAME qualifies as several things.  When this
     function exists, POINT is at the definition.  If the doc was not
     found, an error is thrown.  Note: TYPE not yet implemented.


File: semantic-appdev.info,  Node: Making New Methods,  Prev: Tag Details,  Up: Override Methods

Making New Methods
==================


File: semantic-appdev.info,  Node: Parser Features,  Next: Semantic Database,  Prev: Override Methods,  Up: Top

Parser Features
***************

If you write a program that uses a tag table in a persistent display or
database, it is necessary to know when tag tables change so that your
displays can be updated.  This is especially important as tags can be
replaced, changed, or deleted, and the associated overlays will then
throw errors when you try to use them.  Complete integration with tag
changes can be achieved via several hooks.

If you write an application that frequenly accesses the tags tables, it
is important to make sure those tags are up to date, and to make sure
you application does not adversely effect all the other minor modes
that may be running.

The semantic parser has many features and hooks that applications can
use to provide a good user experience.

* Menu:

* Editing Buffers::             Let the parser know you are changing a buffer.
* Parser State::                Knowing if the tag table is out of date
* Parser Hooks::                Knowing when tags change
* Lexical Safety::              Preventing lexical errors from making a mess


File: semantic-appdev.info,  Node: Editing Buffers,  Next: Parser State,  Up: Parser Features

Editing Buffers
===============

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

 - Variable: semantic-edits-are-safe
     When non-`nil', modifications do not require a reparse.  This
     prevents tokens from being marked dirty, and it prevents top level
     edits from causing a cache check.  Use this when writing programs
     that could cause a full reparse, but will not change the tag
     structure, such as adding or updating top-level comments.


File: semantic-appdev.info,  Node: Parser State,  Next: Parser Hooks,  Prev: Editing Buffers,  Up: Parser Features

Parser State
============

It is sometimes useful to know what the current parsing state is.
These function can let you know what level of re-parsing may be needed.
Careful choices on when to reparse can make your program much faster.

 - Function: semantic-parse-tree-needs-update-p
     Return non-`nil' if the current parse tree needs to be updated.

 - Function: semantic-parse-tree-needs-rebuild-p
     Return non-`nil' if the current parse tree needs to be rebuilt.

 - Function: semantic-parse-tree-unparseable-p
     Return non-`nil' if the current buffer has been marked unparseable.

 - Function: semantic-parse-tree-up-to-date-p
     Return non-`nil' if the current parse tree is up to date.


File: semantic-appdev.info,  Node: Parser Hooks,  Next: Lexical Safety,  Prev: Parser State,  Up: Parser Features

Parser Hooks
============

If you just want to know when a buffer changes, use this hook.

 - Variable: semantic-after-toplevel-cache-change-hook
     Hooks run after the buffer token list has changed.  This list will
     change when a buffer is reparsed, or when the token list in a
     buffer is cleared.  It is *NOT* called if the current token list
     partially reparsed.

     Hook functions must take one argument, which is the new list of
     tokens associated with this buffer.

     For language specific hooks, make sure you define this as a local
     hook.

If you want tighter interaction with how the user is editing different
tags, you can use this hook instead.

 - Variable: semantic-after-partial-cache-change-hook
     Hooks run after the buffer cache has been updated.

     This hook will run when the cache has been partially reparsed.
     Partial reparses are incurred when a user edits a buffer, and only
     the modified sections are rescanned.

     Hook functions must take one argument, which is the list of tokens
     updated in the current buffer.

     For language specific hooks, make sure you define this as a local
     hook.

It is also useful to clean up any data your application is using when
semantic flushes its tags table.

 - Variable: semantic-before-toplevel-cache-flush-hook
     Hooks run before the toplevel nonterminal cache is flushed.  For
     language specific hooks, make sure you define this as a local
     hook.  This hook is called before a corresponding
     `semantic-after-toplevel-cache-change-hook' which is also called
     during a flush when the cache is given a new value of nil.


File: semantic-appdev.info,  Node: Lexical Safety,  Prev: Parser Hooks,  Up: Parser Features

Lexical Safety
==============

If you application frequenly requests lists of tags upon user request,
it may be important to avoid lexical problems that frequenly occur when
the user has partially written an expression, such as starting a
string, or argument list.

You can protect your code from lexical problems with this macro:

 - Function: semantic-lex-catch-errors symbol &rest forms
     Using SYMBOL, execute FORMS catching lexical errors.  If FORMS
     results in a call to the parser that throws a lexical error, the
     error will be caught here without the buffer's cache being thrown
     out of date.  If there is an error, the syntax that failed is
     returned.  If there is no error, then the last value of FORMS is
     returned.

It is important to provide a good SYMBOL so that these macros can nest
correctly.

If you want your code to run anyway, even if there is a lexical error,
using this macro like this:

     (semantic-lex-catch-errors
        (semantic-fetch-tags))

will put the parser into the 'unparseable' state, and allow other
routines to request the tag table without incurring additional parser
attempts.


File: semantic-appdev.info,  Node: Semantic Database,  Next: Idle Scheduling,  Prev: Parser Features,  Up: Top

Semantic Database
*****************

Semanticdb is a database mechanism for storing tags parsed by semantic.
The database operates in the background, saving tags as they are
parsed between sessions.  When a file is read in, and there is a
previously created set of tags available for it, sematnicdb will save
time by not parsing the file, and using the cached copy.

In applications, semanticdb can provide access to the sum of all tags
in a project or in the basic system.  This database can they be
searched using a set of special routines.

* Menu:

* Semanticdb in Programs::      Basic usage.
* Semanticdb Tag Queries::      Searching for tokens in the databases.
* System Databases::            Special kinds of databases for system tags.


File: semantic-appdev.info,  Node: Semanticdb in Programs,  Next: Semanticdb Tag Queries,  Up: Semantic Database

Semanticdb in Programs::
========================

If you write a program using semanticdb, you will probably want to make
sure it is active in your program.

 - Function: semanticdb-minor-mode-p
     Return non-`nil' if `semanticdb-minor-mode' is active.

Since semanticdb is optional, it is best if a program can gracefully
degrade service when semanticdb is not available, or to throw an error
letting the user know it is required to be active.

At the simplest level, you can ask if a given file is in the database,
recieving a tag table.  Semanticdb will give you an accurate set of
tags just by asking.

 - Function: semanticdb-file-stream file
     Return a list of tags belonging to FILE.  If file has database
     tags available in the database, return them.  If file does not
     have tags available, then load the file, and create them.


File: semantic-appdev.info,  Node: Semanticdb Tag Queries,  Next: System Databases,  Prev: Semanticdb in Programs,  Up: Semantic Database

Semanticdb Tag Queries
======================

You can search for tokens in the database using the following
functions.  It is important to note that database search functions do
not return a plain list of tokens.  This is because some tokens may not
be loaded in a buffer, which means that the found token would not have
an overlay, and no way to determine where it came from.

As such, all search functions return a special Database Results list.

There are several types of searches, divided into groups by
implementation.  While it is possible to add new types of searches, or
write custom searches, the built in searches are usually the only ones
available in system backends *Note System Databases::.

When the term brute or brutish is used as a search criteria, that is
distinguishing between an include-path based search, and a search that
scans everything available in a project.

Non-brute force searches assume that all symbols available in a given
buffer are on the search path, or in some file that has been included,
imported, or otherwise indicated in the source file itself.  While not
always true for interpreted languages (such as Emacs Lisp), it is
common among declaritive languages.

Sometimes a brute force aproach is needed, scanning every file
available to the database.  You may want to do this if your application
is collecting some large database unrelated to a file currently being
worked on.

As such, you can determine the full path of all files to search using
the following override method:

 - Function: semanticdb-find-translate-path path brutish
     Translate PATH into a list of semantic tables.  Path translation
     involves identifying the PATH input argument in one of the
     following ways:  `nil' - Take the current buffer, and use it's
     include list  buffer - Use that buffer's include list.   filename
     - Use that file's include list.  If the file is not      in a
     buffer, see of there is a semanticdb table for it.  If      not,
     read that file into a buffer.   tag - Get that tag's buffer of
     file file.  See above.   table - Search that table, and it's
     include list.  In addition, once the base path is found, there is
     the possibility of each added table adding yet more tables to the
     path, so this routine can return a lengthy list.  If argument
     BRUTISH is non-`nil', then instead of using the include list, use
     all tables found in the parent project of the table identified by
     translating PATH.  Such searches use brute force to scan every
     available table.  This routine uses
     "semanticdb-find-table-for-include" to translate specific include
     tags into a semanticdb table.  This function can be overriden in
     semantic using the symbol "semanticdb-find-translate-path".

 - Function: semanticdb-find-table-for-include includetag &optional
          table
     For a single INCLUDETAG found in TABLE, find a "semanticdb-table"
     object INCLUDETAG is a semantic TAG of class 'include.  TABLE as
     defined by "semantic-something-to-tag-table" to identify where the
     tag came from.  TABLE is optional if INCLUDETAG has an overlay of
     `:filename' attribute.  This function can be overriden in semantic
     using the symbol "semanticdb-find-table-for-include".

* Menu:

* DB Results::                  Accessing the results of a search.
* DB Basic Name Search::        Searches based on name.
* DB Basic Brute Search::       Searches on common tag attributes.
* DB Advanced Search::          Complex searches on associations
* DB Generic Brute Search::     Do It Yourself search criteria


File: semantic-appdev.info,  Node: DB Results,  Next: DB Basic Name Search,  Up: Semanticdb Tag Queries

DB Results
----------

The successful results of a search returns a special list of the
following form:

        ( (DATABASE TOKEN1 TOKEN2 ...) (DATABASE2 TOKEN3 TOKEN4 ...) ...)

It should not be necessary to access the results in this way, however,
as there are several routines that can be used to access this list.

To turn a semanticdb search result into a simple tag table, use:

 - Function: semanticdb-strip-find-results results &optional
          find-file-match
     Strip a semanticdb search RESULTS to exclude objects.  This makes
     it appear more like the results of a `semantic-find-' call.
     Optional FIND-FILE-MATCH is not yet implemented.

To write a function that accepts a tag table, or a semanticdb search
result, use this to test if it is a semanticdb search result:

 - Function: semanticdb-find-results-p resultp
     Non-`nil' if RESULTP is in the form of a semanticdb search result.
     This query only really tests the first entry in the list that is
     RESULTP, but should be good enough for debugging assertions.

 - Function: semanticdb-find-result-with-nil-p resultp
     Non-`nil' of RESULTP is in the form of a semanticdb search result.
     `nil' is a valid value where a TABLE usually is, but only if the
     TAG results include overlays.  This query only really tests the
     first entry in the list that is RESULTP, but should be good enough
     for debugging assertions.

To operate on the search results as though it were a simple tags table,
or plain list, use these routines.

 - Function: semanticdb-find-result-length result
     Number of tags found in RESULT.

 - Function: semanticdb-find-result-nth result n
     In RESULT, return the Nth search result.  This is a 0 based search
     result, with the first match being element 0.

     The returned value is a cons cell: (TAG . TABLE) where TAG is the
     tag at the Nth position.  TABLE is the semanticdb table where the
     TAG was found.  Sometimes TABLE can be nil.

 - Function: semanticdb-find-result-nth-in-buffer result n
     In RESULT, return the Nth search result.  Like
     "semanticdb-find-result-nth", except that only the TAG is
     returned, and the buffer it is found it will be made current.  If
     the result tag has no position information, the originating buffer
     is still made current.


File: semantic-appdev.info,  Node: DB Basic Name Search,  Next: DB Basic Brute Search,  Prev: DB Results,  Up: Semanticdb Tag Queries

DB Basic Name Search
--------------------

These searches scan a database table collection for tags based on name.
They are divided into normal and deep searches.  A deep search, as
with in buffer tag scanning, implies that all entries are scanned,
including those in type declarations.

Normal Searches:

 - Function: semanticdb-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-by-name-regexp regexp &optional path
          find-file-match
     Search for all tags matching REGEXP on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-for-completion prefix &optional path
          find-file-match
     Search for all tags matching PREFIX on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-find-tags-by-class class &optional path
          find-file-match
     Search for all tags of CLASS on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

Deep Searches:

 - Function: semanticdb-deep-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-deep-find-tags-by-name-regexp regexp &optional
          path find-file-match
     Search for all tags matching REGEXP on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 - Function: semanticdb-deep-find-tags-for-completion prefix &optional
          path find-file-match
     Search for all tags matching PREFIX on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.


File: semantic-appdev.info,  Node: DB Basic Brute Search,  Next: DB Advanced Search,  Prev: DB Basic Name Search,  Up: Semanticdb Tag Queries

DB Basic Brute Search
---------------------

These searches allow searching on specific attributes of tags,  such as
name, type, or other attribute.

 - Function: semanticdb-brute-deep-find-tags-by-name name &optional
          path find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.  The
     argument BRUTISH will be set so that searching includes all tables
     in the current project.  FIND-FILE-MATCH indicates that any time a
     matchi is found, the file associated wit that tag should be loaded
     into a buffer.


File: semantic-appdev.info,  Node: DB Advanced Search,  Next: DB Generic Brute Search,  Prev: DB Basic Brute Search,  Up: Semanticdb Tag Queries

DB Advanced Search
------------------

These are searches that were needed to accomplish some  specialized
tasks as discovered in utilities.  Advanced searches  include matching
methods defined outside some parent class.

The reason for advanced searches are so that external  repositories
such as the Emacs obarray, or java `.class' files can  quickly answer
these needed questions without dumping the entire  symbol list into
Emacs for a regular semanticdb search.

 - Function: semanticdb-find-tags-external-children-of-type type
          &optional path find-file-match
     Search for all tags defined outside of TYPE w/ TYPE as a parent.
     See "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.


File: semantic-appdev.info,  Node: DB Generic Brute Search,  Prev: DB Advanced Search,  Up: Semanticdb Tag Queries

DB Generic Brute Search
-----------------------

The generic search, "semanticdb-find-nonterminal-by-function"  will
call your function with every tag available.  (Very slow for  system
databases.)

NOTE:  There is no such function.  Hopefully we can get away without
implementing one, which will make system databases more useful.  If you
are really stuck, you can use the following, though I don't recommend
it.

 - Function: semanticdb-find-tags-collector function &optional path
          find-file-match brutish
     Search for all tags returned by FUNCTION over PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.  If
     optional argument BRUTISH is non-`nil', then ignore include
     statements, and search all tables in this project tree.


File: semantic-appdev.info,  Node: System Databases,  Prev: Semanticdb Tag Queries,  Up: Semantic Database

System Databases
================

System Databases are special implementations of the database and table
API which make some external tag source appear as though it were a
normal buffer with semantic parsed tags available.

Search routines for these databases return a special type of table not
associated with a file.  It is important to be aware of this possible
return value.

At this time, there is only one type:

 - Type: semanticdb-project-database-emacs-lisp
     Database representing Emacs core.

Semantic Prased System Databases
--------------------------------

Another kind of system database is one created by the semantic tools,
but saved in a special way.  These databases are created with a script,
or at some other convenient time.  They can then be searched normally.
They will appear on the same list of system databases as back ends that
refer to object files indirectly.


File: semantic-appdev.info,  Node: Idle Scheduling,  Next: Example Programs,  Prev: Semantic Database,  Up: Top

Idle Scheduling
***************

The Semantic Idle Scheduler is a minor mode which performs semantic
specific tasks in idle time.  See *note (semantic-user.info)Idle
Scheduler::.

It performs the following tasks in order:

  1. Reprarse the current buffer if needed

  2. Reparse other buffers that need it

  3. Execute other scheduled semantic related operations.

Care is take in the idle scheduler to exit immediatly if user input is
detected, improving editing performance.

The reason for grouping these tasks together is so that the automatic
reparsing code executes before other idle services.  This allows
lexically broken buffers to be detected so that the other applications
that follow do not accidentally reparse the buffer leaving unmatched
syntax all over.

You can create new minor modes that are automatically scheduled by the
semantic idle scheduler.  Create the new minor mode with:

 - Function: define-semantic-idle-service name doc &rest forms
     Create a new idle services with NAME.  DOC will be a documentation
     string describing FORMS.  FORMS will be called during idle time
     after the current buffer's semantic tag information has been
     updated.  This routines creates the following functions and
     variables:

User Input Handling
===================

When writing an idle service, it is important for tasks that can take a
long time to correctly exit upon user input.

You can test for user input in your idle handler with the following
routines:

 - Function: semantic-throw-on-input from
     Exit with "throw" when in "semantic-exit-on-input" on user input.
     FROM is an indication of where this function is called from as a
     value to pass to "throw".  It is recommended to use the name of
     the function calling this one.

If you need to carefully extract from your function, you can wrap just
a section of your function to exit on user input by wrapping it with
this macro:

 - Function: semantic-exit-on-input symbol &rest forms
     Using SYMBOL as an argument to "throw", execute FORMS.  If FORMS
     includes a call to `semantic-thow-on-input', then if a user
     presses any key during execution, this form macro will exit with
     the value passed to "semantic-throw-on-input".  If FORMS
     completes, then the return value is the same as "progn".

Upon catching user input, you can try to detect if there was an exit
from the return argument, and continue throwing with an additional call
to `semantic-throw-on-input'.


File: semantic-appdev.info,  Node: Example Programs,  Next: Current Context,  Prev: Idle Scheduling,  Up: Top

Programming Examples
********************

*** NOTE ***  These examples are for semantic 1.4.  Using the below
functions will generate compile time warnings with advice on what
functions to use in semantic 2.0.

Here are some simple examples that use different aspects of the
semantic library APIs.  For fully functional example programs with lots
of comments, see the file `semantic-examples.el'.

Interactively querying for a token name
=======================================

If you need a command that asks the user for a token name, you can get
full range completion using the query functions *Note Tag Completion::.

     (interactive (list (semantic-read-symbol "Symbol: ")))

Finding a symbol in a buffer
============================

If you have the name of a function or variable, and need to find its
location in a buffer, you need a search function.  There is a wide
range of searches you can perform *Note Searching Tag Tables::.

     (semantic-find-nonterminal-by-name
      "some-name"
      (current-buffer)
      t    ;; look inside structures and classes for these symbols
      nil) ;; do not look inside header files.

Finding a symbol in a project
=============================

If you have the name of a function or variable, and need to find its
location somewhere in a project, you need to use the Semantic Database
*note (semanticdb)semanticdb::.  There are many search functions
similar to the ones found in *Note Searching Tag Tables::.

The Semantic Database is interesting in that the return structure is not

Locating a token in a buffer
============================

If you have a nonterminal token, or a list of them, you may want to
find their position in a buffer.

     (semanticdb-find-nonterminal-by-name
      "symbol"
      nil   ;; Defaults to the current project's database list.
      t     ;; Search inside types
      nil   ;; Do not search include files
      nil   ;; Only search files in the same mode (all C files)
      t     ;; When a token is found, make sure it is loaded in a buffer.
      )

Of interesting note above, semanticdb can find symbols in files that
are not loaded into an Emacs buffer.  These tokens do not have an
associated overlay, and the function "semantic-token-buffer" will fail.

The last parameter's tells the search function to "find-file-noselect"
any file in which a matching token was found.  This will allow you to
merge all the tokens into a completion list, or other flat list needed
by most functions that use association lists.

If you do not ask semanticdb to load those files, you will need to
explicitly request the database object (found in the `car' of each
sublist) get the file loaded.  It is useful to not auto find all files
if you don't need to jump to that token.

Converting a token into a human readable string.
================================================

A tag is a rather unpleasant Lisp structure when trying to decipher
what is going on.  As such, there is a wide range of functions
available that can convert a token into a human readable, and colorful
string *Note Format Tag::.

If you program interfaces with lots of users, you will probably want to
have your program define a configurable variable that will let users
change the visible portion of your program.

     (defcustom my-summary-function 'semantic-uml-prototype-nonterminal
       "*Function to use when showing info about my tag."
       :group 'my-program
       :type semantic-format-tag-custom-list)

Note the special type provided by Semantic.

Next, you can call this function to create a string.

     (funcall my-summary-function tag
                                  tag-parent
                                  t ; use color
                                  )

In this case, TAG-PARENT is an optional argument.  In many cases,
parent is not used by the outputting function.  The parent must be a
tag whose `semantic-tag-componenets' contains TAG, or nil for top-level
definitions.  In particular, C++ needs the parent to correctly
calculate the protection of each method.

